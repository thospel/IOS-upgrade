#!/usr/bin/env python3
import sys
import os
from pathlib import Path
from subprocess import run
from stat import S_ISREG

import colorama		# type: ignore

FILE = Path(__file__).resolve()
CONFIG_DIR  = FILE.parents[1] / "etc" / "ios-upgrade"
# DEVICE_APPLY = "/opt/Shell/tooling/device-apply/bin/device-apply"
DEVICE_APPLY = "device-apply"
# Setting DEVICE_APPLY_NAME currently doesn't do anything since python fakes
# sys. argv. In python 3.10 a new variable sys.orig_argv will be added
# DEVICE_APPLY_NAME = "device-apply"
DEVICE_APPLY_NAME = "ios-upgrade"
PACKAGE_VERSION = "1.0"
PREFIX = "IOS-upgrade."
VERSION_MIN = "1.5.55"
IOS_TABLE = "cisco_ios.table.txt"
ENV_IOS_TABLE    = "ios_table"
ENV_ACTIONS_NAME = "actions_name"

def red(text: str) -> str:
    """Wrap text in ANSI escapes so it will display as red

    Args:
        text: The text to be decorated as red

    Returns:
        Decorated text
    """
    result: str = colorama.Style.BRIGHT + colorama.Fore.RED + text + colorama.Fore.RESET + colorama.Style.NORMAL
    return result

if __name__=='__main__':
    # Also need to support --verion at sys.argv[1] since make-python-rpm will
    # call the helper script directly
    if len(sys.argv) > 1 and sys.argv[1] == "--version" or \
       len(sys.argv) > 2 and sys.argv[2] == "--version":
            print(PACKAGE_VERSION)
            sys.exit(0)

    if len(sys.argv) < 2 or sys.argv[1].startswith("-"):
        raise SystemExit(red("Attempt to call IOS-upgrade.helper directly. Please use one of the wrapper programs instead"))

    if len(sys.argv) > 2:
        if sys.argv[2] in ("--help", "-h"):
            os.execvp(DEVICE_APPLY,
                      [DEVICE_APPLY_NAME, "--help"])

    name = Path(sys.argv[1]).name
    if not name.startswith(PREFIX):
        raise SystemExit(red(f"Assertion: Wrapper script name {name!r} does not start with {PREFIX!r}"))
    name = name[len(PREFIX):]
    os.environ[ENV_ACTIONS_NAME] = name

    # Make sure IOS_TABLE is usable. These tests are a race condition since the
    # situation can have changed by the time of the actual usage, but that does
    # not matter since that usage will still error in case of problems, it's
    # just that these error will be a lot less clear
    ios_table_path = Path(IOS_TABLE).resolve()
    try:
        stat = ios_table_path.stat()
    except IOError as exc:
        raise SystemExit(red(str(exc).replace(str(ios_table_path), IOS_TABLE))) from None
    if not S_ISREG(stat.st_mode):
        raise SystemExit(red(f"Path {IOS_TABLE!r} exists but is not a regular file"))
    try:
        with open(ios_table_path):
            pass
    except IOError as exc:
        raise SystemExit(red(str(exc).replace(str(ios_table_path), IOS_TABLE))) from None
    os.environ[ENV_IOS_TABLE]   = str(ios_table_path)

    result = run([DEVICE_APPLY_NAME,
                  "--version-min", VERSION_MIN,
                  "--no-verbose",
                  "-W", "-",
                  "-A", str(CONFIG_DIR / "IOS.check_table.actions.txt"),
                  os.devnull],
                 executable = DEVICE_APPLY,
                 text=True,
                 capture_output=True)
    if result.returncode:
        print(red(result.stderr.strip() or result.stdout.strip() or "Unknown error"))
        sys.exit(result.returncode if result.returncode > 0 else 1)

    if name == "check":
        extra_args = ["-W", "-"]
    else:
        extra_args = []
    os.execvp(DEVICE_APPLY,
              [DEVICE_APPLY_NAME,
               "--verbose",
               "--no-check-alone",
               "-A", str(CONFIG_DIR / ("%s.actions.txt" % name)),
               *extra_args,
               *sys.argv[2:]])
